# 실시간 상승률 상위 30위 조회 기능 안내

현재 시스템은 키움증권 API의 **WebSocket** 통신을 이용하여 실시간으로 상승률 상위 30위 종목을 조회하고 있습니다. 이는 주기적으로 서버에 요청을 보내는 REST API 방식보다 실시간 데이터 수신에 더 효율적입니다.

## ✅ 현재 구현 방식 요약

1.  **Python WebSocket 클라이언트 (`get_top_30_rising_stocks.py`)**:
    *   키움증권 모의투자 WebSocket 서버(`wss://...`)에 접속합니다.
    *   발급받은 접근 토큰으로 로그인을 요청합니다.
    *   로그인 성공 후, `trnm: 'UPRATE30'` 파라미터를 전송하여 상승률 상위 30위 종목을 실시간으로 요청합니다.
    *   서버로부터 받은 데이터를 JSON 형식으로 출력하고 연결을 종료합니다.

2.  **PHP 웹 페이지 (`top_30_rising_stocks.php`)**:
    *   위 Python 스크립트를 서버에서 실행합니다.
    *   스크립트가 출력한 JSON 데이터를 받아 파싱합니다.
    *   결과를 HTML 테이블 형태로 가공하여 사용자에게 보여줍니다.

3.  **통합 페이지 (`api_info.php`)**:
    *   `api_info.php` 페이지 내에 `top_30_rising_stocks.php` 파일이 포함되어 있어, API 정보와 함께 상승률 상위 종목을 한눈에 확인할 수 있습니다.

## 📘 REST API 방식과의 비교

사용자께서 제공해주신 `fn_ka10099` (REST API) 방식도 상승률 상위 종목을 조회하는 유효한 방법입니다. 하지만 이 방법은 **요청 시점의 스냅샷 데이터**를 제공합니다.

반면, 현재 구현된 **WebSocket 방식**은 서버에서 데이터 변경이 발생할 때마다 데이터를 밀어주는(Push) 방식에 더 가까워, **진정한 의미의 실시간 데이터**를 얻는 데 더 적합합니다. 따라서 본 프로젝트에서는 실시간성이 중요한 상승률 순위 조회를 위해 WebSocket을 채택하였습니다.

이 기능은 이미 `api_info.php` 페이지에 성공적으로 통합되어 있습니다.

새롭게 제안드린 방식(WebSocket을 이용한 실시간 데이터 수집)으로 기능을 구현한 전체 소스 코드를 제공해 드립니다.

이 구현은 get_all_stocks.py가 기본적인 종목 리스트를 데이터베이스에 저장하면, 새로운 스크립트인 realtime_data_updater.py가 백그라운드에서 실시간으로 상세 시세 정보를 받아와 데이터베이스를 업데이트하는 방식입니다. 웹페이지는 업데이트된 데이터베이스를 읽어와 표시하게 됩니다.

1. kiwoom_api.py (변경 없음 - 재확인용)
이전에 제공해 드린 kiwoom_api.py 파일과 동일합니다. 콘솔 로깅이 제거되어 PHP가 실행 시 출력으로 인한 문제를 방지합니다.

Python

import requests
import json
import configparser
import sqlite3
import os
import datetime
import logging

# --- 파일 경로 설정 (상대 경로 사용) ---
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.join(CURRENT_DIR, '..')

CONFIG_FILE = os.path.join(PROJECT_ROOT, 'config.ini')
DB_FILE = os.path.join(PROJECT_ROOT, 'stock_data.db')
WORK_CONTENT_FILE = os.path.join(PROJECT_ROOT, 'md_documents', 'doc', '20250718_작업할내용.txt')

# --- 로그 파일 설정 ---
LOG_DIR = os.path.join(PROJECT_ROOT, 'logs')
os.makedirs(LOG_DIR, exist_ok=True)

LOG_FILE = os.path.join(LOG_DIR, f"kiwoom_api_{datetime.datetime.now().strftime('%Y%m%d')}.log")

# 로거 설정
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

file_handler = logging.FileHandler(LOG_FILE, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

def initialize_db():
    """데이터베이스와 테이블을 초기화합니다."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS api_info (
            id INTEGER PRIMARY KEY,
            access_token TEXT,
            account_number TEXT,
            account_name TEXT,
            balance REAL
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS work_in_progress (
            id INTEGER PRIMARY KEY,
            content TEXT,
            last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS korean_stock_list (
            stk_cd TEXT PRIMARY KEY,
            stk_nm TEXT,
            cur_prc REAL,
            cmpr_yd REAL,
            flu_rt TEXT,
            trde_qty INTEGER,
            trde_amt INTEGER,
            last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    conn.commit()
    conn.close()
    logger.info("데이터베이스와 테이블이 초기화되었습니다.")

def save_api_info(access_token, account_number, account_name, balance):
    """API 정보를 데이터베이스에 저장합니다."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM api_info")
    cursor.execute('''
        INSERT INTO api_info (access_token, account_number, account_name, balance)
        VALUES (?, ?, ?, ?)
    ''', (access_token, account_number, account_name, balance))
    conn.commit()
    conn.close()
    logger.info("API 정보가 데이터베이스에 저장되었습니다.")

def get_api_info_from_db():
    """데이터베이스에서 API 정보를 가져옵니다."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT access_token, account_number, account_name, balance FROM api_info LIMIT 1")
    info = cursor.fetchone()
    conn.close()
    return info

def save_work_content(content):
    """진행 중인 작업 내용을 데이터베이스에 저장합니다."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("DELETE FROM work_in_progress")
    cursor.execute('''
        INSERT INTO work_in_progress (content)
        VALUES (?)
    ''', (content,))
    conn.commit()
    conn.close()
    logger.info("진행 중인 작업 내용이 데이터베이스에 저장되었습니다.")

def get_work_content_from_db():
    """데이터베이스에서 진행 중인 작업 내용을 가져옵니다."""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT content FROM work_in_progress ORDER BY last_updated DESC LIMIT 1")
    info = cursor.fetchone()
    conn.close()
    return info[0] if info else ""

def save_all_stocks_to_db(stocks):
    """전체 종목 리스트를 데이터베이스에 저장/업데이트합니다."""
    if not stocks or (isinstance(stocks, dict) and "error" in stocks):
        logger.info("오류가 있거나 저장할 종목 데이터가 없어 DB 저장을 건너뜁니다.")
        return

    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    saved_count = 0
    for stock in stocks:
        if not isinstance(stock, dict) or 'code' not in stock:
            logger.warning(f"유효하지 않은 종목 데이터 형식 또는 'code' 필드 누락: {stock}")
            continue

        stk_cd = stock.get('code')
        stk_nm = stock.get('name')
        cur_prc = float(stock.get('lastPrice', '0').replace(',', '')) if stock.get('lastPrice') else 0.0

        # WebSocket updater가 이 필드들을 채울 것이므로 기본값 유지
        cmpr_yd = 0.0
        flu_rt = ''
        trde_qty = 0
        trde_amt = 0

        cursor.execute('''
            INSERT OR REPLACE INTO korean_stock_list
            (stk_cd, stk_nm, cur_prc, cmpr_yd, flu_rt, trde_qty, trde_amt, last_updated)
            VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        ''', (
            stk_cd, stk_nm, cur_prc, cmpr_yd, flu_rt, trde_qty, trde_amt
        ))
        saved_count += 1

    conn.commit()
    conn.close()
    logger.info(f"총 {saved_count}개의 종목 정보를 데이터베이스에 저장/업데이트했습니다.")

# 접근토큰 발급 함수
def issue_access_token(base_url, data):
    """키움 Open API로부터 접근 토큰을 발급받습니다."""
    host = base_url
    endpoint = '/oauth2/token'
    url = host + endpoint

    headers = {
        'Content-Type': 'application/json;charset=UTF-8',
        'api-id': 'kb00000',
    }
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        res_json = response.json()
        logger.info('--- 토큰 발급 응답 ---')
        logger.info(f"Code: {response.status_code}")
        logger.info(f"Body: {json.dumps(res_json, indent=4, ensure_ascii=False)}")

        if 'access_token' in res_json:
            return {'access_token': res_json['access_token']}
        elif 'token' in res_json:
            return {'access_token': res_json['token']}
        else:
            logger.error("응답에 access_token 또는 token 필드가 없습니다.")
            return None
    except requests.exceptions.RequestException as e:
        logger.error(f"토큰 발급 요청 중 오류 발생: {e}")
        return None
    except json.JSONDecodeError:
        logger.error(f"토큰 발급 응답 JSON 파싱 오류. 응답: {response.text}")
        return None

# 계좌 정보 조회 요청 함수 (kt00004)
def fn_kt00004_get_account_info(base_url, token, data, cont_yn='N', next_key=''):
    """키움 Open API를 통해 계좌 정보를 조회합니다 (kt00004)."""
    host = base_url
    endpoint = '/api/dostk/acnt'
    url = host + endpoint

    headers = {
        'Content-Type': 'application/json;charset=UTF-8',
        'authorization': f'Bearer {token}',
        'cont-yn': cont_yn,
        'next-key': next_key,
        'api-id': 'kt00004',
    }
    try:
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        res_json = response.json()
        logger.info('\n--- 계좌 정보 조회 응답 (kt00004) ---')
        logger.info(f"Code: {response.status_code}")
        logger.info(f"Header: {json.dumps({key: response.headers.get(key) for key in ['next-key', 'cont-yn', 'api-id']}, indent=4, ensure_ascii=False)}")
        logger.info(f"Body: {json.dumps(res_json, indent=4, ensure_ascii=False)}")

        account_info_data = res_json.get('data', [])
        if isinstance(account_info_data, list) and account_info_data:
            first_account = account_info_data[0]
            account_number = first_account.get('entr', 'N/A')
            account_name = first_account.get('acnt_nm', 'N/A')
            balance = float(first_account.get('tot_est_amt', '0').replace(',', ''))
        else:
            account_number = res_json.get('entr', 'N/A')
            account_name = res_json.get('acnt_nm', 'N/A')
            balance = float(res_json.get('tot_est_amt', '0').replace(',', ''))

        return account_number, account_name, balance
    except requests.exceptions.RequestException as e:
        logger.error(f"계좌 정보 조회 요청 (kt00004) 중 오류 발생: {e}")
        return None, None, None
    except json.JSONDecodeError:
        logger.error(f"계좌 정보 조회 응답 (kt00004) JSON 파싱 오류. 응답: {response.text}")
        return None, None, None


def get_kiwoom_token_and_account_info():
    """config.ini에서 API 키를 읽어 토큰을 발급받고 계좌 정보를 조회합니다."""
    config = configparser.ConfigParser()
    config.read(CONFIG_FILE)

    try:
        appkey = config.get('API', 'APP_KEY')
        appsecret_value = config.get('API', 'APP_SECRET')
        base_url = config.get('API', 'BASE_URL')
    except (configparser.NoSectionError, configparser.NoOptionError) as e:
        logger.error(f"오류: config.ini 파일의 내용이 올바르지 않습니다. ({e})")
        logger.error("Please ensure [API] section and APP_KEY, APP_SECRET, BASE_URL keys are present.")
        return None, None, None, None

    params_token = {'grant_type': 'client_credentials', 'appkey': appkey, 'secretkey': appsecret_value}
    token_response = issue_access_token(base_url=base_url, data=params_token)

    if token_response and token_response.get('access_token'):
        access_token = token_response['access_token']
        logger.info("\n토큰 발급 성공. 발급된 토큰으로 계좌 조회를 시작합니다.")

        params_account = {
            'qry_tp': '0',
            'dmst_stex_tp': 'KRX',
        }
        account_number, account_name, balance = fn_kt00004_get_account_info(base_url=base_url, token=access_token, data=params_account)
        return access_token, account_number, account_name, balance
    else:
        logger.error("\n토큰 발급에 실패하여 계좌 조회를 진행할 수 없습니다.")
        return None, None, None, None

if __name__ == "__main__":
    initialize_db()
    token, account_num, account_name, balance = get_kiwoom_token_and_account_info()
    if token:
        save_api_info(token, account_num, account_name, balance)
        logger.info("\nDB에서 정보 확인:")
        db_info = get_api_info_from_db()
        if db_info:
            logger.info(f"토큰 (DB에서): {db_info[0][:5]}**********")
            logger.info(f"계좌 번호 (DB에서): {db_info[1]}")
            logger.info(f"계좌명 (DB에서): {db_info[2]}")
            logger.info(f"잔액 (DB에서): {db_info[3]}")
        else:
            logger.info("DB에서 데이터를 찾을 수 없습니다.")

    if os.path.exists(WORK_CONTENT_FILE):
        with open(WORK_CONTENT_FILE, 'r', encoding='utf-8') as f:
            work_content = f.read()
        save_work_content(work_content)
    else:
        logger.warning(f"경고: 작업 내용 파일이 다음 위치에 없습니다: {WORK_CONTENT_FILE}")
2. get_all_stocks.py (변경 없음 - 재확인용)
이 스크립트는 초기 종목 리스트(종목코드, 종목명, 현재가)를 데이터베이스에 저장하는 역할을 합니다. '전일대비', '등락률', '거래량', '거래대금' 필드는 기본값으로 저장되며, 새롭게 추가될 realtime_data_updater.py가 이 필드들을 채울 것입니다.

Python

import requests
import json
import configparser
import os
import time
import kiwoom_api # kiwoom_api 모듈 import
import logging

logger = logging.getLogger('kiwoom_api')

# --- 파일 경로 설정 (상대 경로 사용) ---
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.join(CURRENT_DIR, '..')

config = configparser.ConfigParser()
config_path = os.path.join(PROJECT_ROOT, 'config.ini')
config.read(config_path)

try:
    APP_KEY = config['API']['APP_KEY']
    APP_SECRET = config['API']['APP_SECRET']
    BASE_URL = config['API']['BASE_URL']
except (configparser.NoSectionError, configparser.NoOptionError) as e:
    logger.error(f"오류: config.ini 파일에 [API] 섹션 또는 필요한 키가 누락되었습니다. ({e})")
    logger.error("[API] 섹션 안에 APP_KEY, APP_SECRET, BASE_URL 키가 있는지 확인해주세요.")
    APP_KEY = None
    APP_SECRET = None
    BASE_URL = None

# 종목정보 조회 (ka10099) - 시장구분 및 페이지네이션 포함
def get_all_stocks_list_by_market(token, base_url, market_type):
    """
    키움 Open API (ka10099)를 통해 특정 시장의 종목 정보를 조회합니다.
    market_type: '0' (코스피), '10' (코스닥)
    """
    host = base_url
    endpoint = '/api/dostk/stkinfo'
    url = host + endpoint

    market_stocks = []
    cont_yn = 'N'
    next_key = ''

    market_name = "코스피" if market_type == '0' else "코스닥"
    logger.info(f"--- {market_name} 종목 정보를 가져오는 중...")

    while True:
        headers = {
            'Content-Type': 'application/json;charset=UTF-8',
            'authorization': f'Bearer {token}',
            'cont-yn': cont_yn,
            'next-key': next_key,
            'api-id': 'ka10099',
        }
        params = {
            'mrkt_tp': market_type,
        }

        try:
            response = requests.post(url, headers=headers, json=params)
            response.raise_for_status()

            res_json = response.json()

            logger.debug(f"Raw API 응답 for {market_name} (Page cont-yn={cont_yn}, next-key={next_key}): {json.dumps(res_json, indent=4, ensure_ascii=False)}")

            if res_json.get('list') and isinstance(res_json['list'], list):
                new_stocks = res_json['list']

                if new_stocks:
                    current_batch_count = len(new_stocks)
                    market_stocks.extend(new_stocks)
                    logger.info(f"({market_name}) 현재 페이지에서 {current_batch_count}개 종목 추가 완료. 현재까지 총 {len(market_stocks)}개 수집.")
                else:
                    logger.info(f"({market_name}) 'list' 필드는 존재하지만 더 이상 종목이 없습니다. 루프를 종료합니다.")
                    break
            else:
                logger.warning(f"API 응답에 'list' 필드가 없거나 유효한 리스트가 아닙니다. 응답: {json.dumps(res_json, indent=4, ensure_ascii=False)}")
                break

            cont_yn = response.headers.get('cont-yn', 'N')
            next_key = response.headers.get('next-key', '')

            if cont_yn != 'Y' or not next_key:
                logger.info(f"({market_name}) 더 이상 다음 페이지가 없습니다. 최종 수집 완료.")
                break

            time.sleep(60)

        except requests.exceptions.RequestException as e:
            logger.error(f"API 요청 중 오류 발생: {e}")
            if e.response is not None:
                logger.error(f"응답 내용: {e.response.text}")
            return []
        except json.JSONDecodeError:
            logger.error(f"응답 JSON 파싱 오류. 응답: {response.text}")
            return []

    logger.info(f"--- 총 {len(market_stocks)}개의 {market_name} 종목 정보 수집 완료.")
    return market_stocks


if __name__ == '__main__':
    logger.info("--- 코스피/코스닥 전종목 정보 업데이트 시작 ---")
    kiwoom_api.initialize_db()

    if not all([APP_KEY, APP_SECRET, BASE_URL]):
        logger.error("필수 API 설정이 누락되었습니다. config.ini 파일을 확인하고 스크립트를 다시 실행해주세요.")
        exit()

    token_params = {
        'grant_type': 'client_credentials',
        'appkey': APP_KEY,
        'secretkey': APP_SECRET,
    }

    token_response = kiwoom_api.issue_access_token(base_url=BASE_URL, data=token_params)

    access_token = token_response.get('access_token') if token_response else None

    if access_token:
        all_stocks = []

        kospi_stocks = get_all_stocks_list_by_market(access_token, BASE_URL, '0')
        all_stocks.extend(kospi_stocks)

        kosdaq_stocks = get_all_stocks_list_by_market(access_token, BASE_URL, '10')
        all_stocks.extend(kosdaq_stocks)

        if all_stocks:
            logger.info(f"\n--- 최종적으로 수집된 전체 종목 수: {len(all_stocks)}개 ---")
            kiwoom_api.save_all_stocks_to_db(all_stocks)
        else:
            logger.info("수집된 종목 정보가 없어 DB 저장을 건너깁니다.")
    else:
        logger.error("토큰 발급 실패로 인해 종목 정보를 업데이트할 수 없습니다. 위 로그를 확인해주세요.")

    logger.info("--- 전종목 정보 업데이트 완료 ---")
3. realtime_data_updater.py (새롭게 추가)
이 스크립트는 python_modules 폴더에 새로 생성해야 합니다. WebSocket을 통해 실시간 데이터를 수신하고 stock_data.db에 업데이트합니다.

Python

import asyncio
import websockets
import json
import configparser
import os
import sqlite3
import datetime
import logging
import time # For sleep in main loop
import kiwoom_api # kiwoom_api 모듈 import

# --- 파일 경로 및 로거 설정 (kiwoom_api와 일관되게 설정) ---
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.join(CURRENT_DIR, '..')

CONFIG_FILE = os.path.join(PROJECT_ROOT, 'config.ini')
DB_FILE = os.path.join(PROJECT_ROOT, 'stock_data.db')
LOG_DIR = os.path.join(PROJECT_ROOT, 'logs')
os.makedirs(LOG_DIR, exist_ok=True)

LOG_FILE = os.path.join(LOG_DIR, f"realtime_updater_{datetime.datetime.now().strftime('%Y%m%d')}.log")
logger = logging.getLogger(__name__) # Use __name__ to differentiate from kiwoom_api's logger
logger.setLevel(logging.INFO)
file_handler = logging.FileHandler(LOG_FILE, encoding='utf-8')
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(file_handler)

# --- 설정 로드 ---
config = configparser.ConfigParser()
config.read(CONFIG_FILE)

try:
    BASE_URL = config.get('API', 'BASE_URL')
    APP_KEY = config.get('API', 'APP_KEY')
    APP_SECRET = config.get('API', 'APP_SECRET')
    SOCKET_URL = 'wss://mockapi.kiwoom.com:10000/api/dostk/websocket' # 모의투자 WebSocket URL 고정
except (configparser.NoSectionError, configparser.NoOptionError) as e:
    logger.error(f"오류: config.ini 파일의 내용이 올바르지 않습니다. ({e})")
    logger.error("Please ensure [API] section and BASE_URL, APP_KEY, APP_SECRET keys are present.")
    BASE_URL = None
    APP_KEY = None
    APP_SECRET = None
    SOCKET_URL = None

# --- DB 업데이트 유틸리티 함수 ---
def update_stock_realtime_data(stock_code, data):
    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # 실제 API 응답에 따라 키 이름은 달라질 수 있습니다.
        # 아래는 예상되는 키 이름이며, 실제 응답을 보고 맞춰야 합니다.
        # 사용자 제공 예시 (0A 타입)를 기반으로 일반적인 필드를 추정합니다.
        
        # 'current_price' 대신 'lastPrice'를 사용할 가능성 있음 (get_all_stocks.py와 일관)
        current_price = float(data.get('lastPrice', '0').replace(',', '')) if data.get('lastPrice') else 0.0
        # 이하는 Mock API의 0A 타입이 어떤 필드를 제공하는지에 따라 달라집니다.
        # 임시로 'changeFromPrevDay', 'fluctuationRate', 'tradeVolume', 'tradeAmount'를 사용합니다.
        # 실제 API 응답에서 해당 값들의 정확한 키 이름을 확인하고 필요 시 수정해야 합니다.
        change_from_prev_day = float(data.get('changeFromPrevDay', '0').replace(',', '')) if data.get('changeFromPrevDay') else 0.0
        fluctuation_rate = str(data.get('fluctuationRate', ''))
        trade_volume = int(data.get('tradeVolume', '0').replace(',', '')) if data.get('tradeVolume') else 0
        trade_amount = int(data.get('tradeAmount', '0').replace(',', '')) if data.get('tradeAmount') else 0

        cursor.execute('''
            UPDATE korean_stock_list
            SET cur_prc = ?, cmpr_yd = ?, flu_rt = ?, trde_qty = ?, trde_amt = ?, last_updated = CURRENT_TIMESTAMP
            WHERE stk_cd = ?
        ''', (current_price, change_from_prev_day, fluctuation_rate, trade_volume, trade_amount, stock_code))
        conn.commit()
        logger.debug(f"DB 업데이트 완료: 종목코드={stock_code}, 현재가={current_price}, 전일대비={change_from_prev_day}, 등락률={fluctuation_rate}, 거래량={trade_volume}, 거래대금={trade_amount}")
    except Exception as e:
        logger.error(f"종목 {stock_code}의 실시간 데이터 DB 업데이트 중 오류 발생: {e}")
    finally:
        if conn:
            conn.close()

# --- WebSocket 클라이언트 클래스 ---
class WebSocketClient:
    def __init__(self, uri, access_token):
        self.uri = uri
        self.access_token = access_token
        self.websocket = None
        self.connected = False
        self.keep_running = True
        self.stock_codes_to_subscribe = []

    async def connect(self):
        try:
            self.websocket = await websockets.connect(self.uri)
            self.connected = True
            logger.info("서버와 연결을 시도 중입니다.")

            param = {
                'trnm': 'LOGIN',
                'token': self.access_token
            }

            logger.info('실시간 시세 서버로 로그인 패킷을 전송합니다.')
            await self.send_message(message=param)

        except Exception as e:
            logger.error(f'연결 오류 발생: {e}')
            self.connected = False
            await asyncio.sleep(5)

    async def send_message(self, message):
        if not self.connected:
            await self.connect()
        if self.connected:
            if not isinstance(message, str):
                message = json.dumps(message)

            try:
                await self.websocket.send(message)
                logger.debug(f'메시지 전송: {message}')
            except websockets.exceptions.ConnectionClosedOK:
                logger.warning("메시지 전송 중 연결이 끊어졌습니다. 재연결 시도...")
                self.connected = False
                await self.connect()
                if self.connected:
                    await self.websocket.send(message)
            except Exception as e:
                logger.error(f"메시지 전송 오류: {e}")
                self.connected = False

    async def receive_messages(self):
        while self.keep_running:
            try:
                response_str = await self.websocket.recv()
                response = json.loads(response_str)

                if response.get('trnm') == 'LOGIN':
                    if response.get('return_code') != 0:
                        logger.error(f'로그인 실패: {response.get("return_msg")}')
                        await self.disconnect()
                    else:
                        logger.info('로그인 성공.')
                        await self.subscribe_to_stocks()

                elif response.get('trnm') != 'PING':
                    logger.info(f'실시간 시세 서버 응답 수신: {response}')
                    if response.get('trnm') == 'REAL' and response.get('item'):
                        stock_code = response['item']
                        # '0A' 타입의 응답 구조에 따라 데이터 추출
                        # Mock API의 실제 응답 구조를 확인하여 필드 이름을 조정하세요.
                        realtime_data = response.get('0A', response)
                        update_stock_realtime_data(stock_code, realtime_data)

            except websockets.ConnectionClosed:
                logger.warning('서버에 의해 연결이 끊어졌습니다. 재연결 시도...')
                self.connected = False
                await self.websocket.close()
                await asyncio.sleep(5)
                if self.keep_running:
                    await self.connect()
            except json.JSONDecodeError:
                logger.error(f"JSON 파싱 오류. 수신된 응답: {response_str[:200]}...")
            except asyncio.CancelledError:
                logger.info("메시지 수신 태스크가 취소되었습니다.")
                break
            except Exception as e:
                logger.error(f'메시지 수신 오류: {e}')
                await asyncio.sleep(1)

    async def run(self):
        while self.keep_running:
            if not self.connected:
                await self.connect()
                if not self.connected:
                    await asyncio.sleep(10)
                    continue
            await self.receive_messages()

    async def subscribe_to_stocks(self):
        if not self.stock_codes_to_subscribe:
            logger.info("구독할 종목 코드가 없습니다. 데이터베이스에서 종목 코드를 로드해주세요.")
            return

        # 모든 종목 코드를 한 번에 'item' 리스트에 담아 구독 요청
        # 실제 API는 동시에 구독할 수 있는 항목 수에 제한이 있을 수 있습니다.
        # (예: 100개 항목 제한). 제한에 걸리면 여러 번에 나누어 요청해야 합니다.
        subscription_data_entry = {
            'item': self.stock_codes_to_subscribe, # 모든 종목 코드를 리스트로 전달
            'type': ['0A'], # 기본 실시간 시세 (체결) 데이터 타입
        }

        reg_message = {
            'trnm': 'REG',
            'grp_no': '1',
            'refresh': '1',
            'data': [subscription_data_entry]
        }

        logger.info(f"실시간 항목 등록 요청 전송 (총 {len(self.stock_codes_to_subscribe)}개 종목).")
        await self.send_message(reg_message)
        logger.info("실시간 항목 등록 요청 전송 완료.")


    async def disconnect(self):
        self.keep_running = False
        if self.connected and self.websocket:
            await self.websocket.close()
            self.connected = False
            logger.info('WebSocket 서버 연결 해제됨')

# --- 메인 실행 로직 ---
async def main():
    logger.info("--- 실시간 종목 시세 업데이트 스크립트 시작 ---")

    if not all([APP_KEY, APP_SECRET, BASE_URL, SOCKET_URL]):
        logger.error("config.ini에서 API 설정 또는 WebSocket URL을 로드할 수 없습니다.")
        return

    # 접근 토큰 발급 (kiwoom_api 모듈 재사용)
    token_data = {'grant_type': 'client_credentials', 'appkey': APP_KEY, 'secretkey': APP_SECRET}
    token_response = kiwoom_api.issue_access_token(base_url=BASE_URL, data=token_data)
    access_token = token_response.get('access_token') if token_response else None

    if not access_token:
        logger.error("접근 토큰을 발급받을 수 없어 실시간 업데이트를 시작할 수 없습니다.")
        return

    # DB에서 모든 종목 코드 로드
    all_stock_codes = []
    conn = None
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("SELECT stk_cd FROM korean_stock_list")
        all_stock_codes = [row[0] for row in cursor.fetchall()]
        logger.info(f"데이터베이스에서 총 {len(all_stock_codes)}개의 종목 코드를 로드했습니다.")
        if not all_stock_codes:
            logger.warning("데이터베이스에 종목 코드가 없습니다. get_all_stocks.py를 먼저 실행하여 종목을 로드해주세요.")
            return
    except Exception as e:
        logger.error(f"데이터베이스에서 종목 코드를 로드하는 중 오류 발생: {e}")
        return
    finally:
        if conn:
            conn.close()

    websocket_client = WebSocketClient(SOCKET_URL, access_token)
    websocket_client.stock_codes_to_subscribe = all_stock_codes

    receive_task = asyncio.create_task(websocket_client.run())

    # 스크립트가 계속 실행되도록 유지 (비동기 태스크를 백그라운드에서 실행)
    try:
        while True:
            await asyncio.sleep(3600) # 1시간마다 깨어나 연결 상태 확인 등 (실제 로직은 receive_messages에서 처리)
    except asyncio.CancelledError:
        logger.info("메인 루프가 취소되었습니다.")
    finally:
        await websocket_client.disconnect()
        logger.info("--- 실시간 종목 시세 업데이트 스크립트 종료 ---")


if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("스크립트가 사용자 요청에 의해 종료되었습니다.")
    except Exception as e:
        logger.error(f"스크립트 실행 중 예기치 않은 오류 발생: {e}")
4. fetch_all_stocks.php (변경 없음 - 재확인용)
이전에 수정해 드린 fetch_all_stocks.php 파일과 동일합니다. 이 파일은 stock_data.db에서 데이터를 읽기만 합니다.

PHP

<?php
// Set a longer timeout for this script as fetching all stocks from DB might take time for large datasets.
set_time_limit(120); // 2 minutes, adjusted from 5 minutes as Python execution is removed.

// 이 PHP 스크립트는 데이터베이스에서 종목 정보를 읽어와 HTML로 출력합니다.
// 파이썬 스크립트(get_all_stocks.py)는 별도의 스케줄러(예: cron job)를 통해
// 주기적으로 실행되어 데이터베이스를 업데이트해야 합니다.
// 웹 요청 시마다 파이썬 스크립트를 실행하는 것은 비효율적이며, API 요청 제한에 걸릴 수 있습니다.

$search_term = $_GET['search'] ?? '';
$db_file = '/home/stock/public_html/stock_data.db'; // stock_data.db 파일의 실제 경로

$data = [];
$error_message = '';

try {
    $pdo = new PDO('sqlite:' . $db_file);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    $pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC); // 결과를 연관 배열로 가져오기

    $sql = "SELECT stk_cd, stk_nm, cur_prc, cmpr_yd, flu_rt, trde_qty, trde_amt FROM korean_stock_list";
    $params = [];

    if (!empty($search_term)) {
        $sql .= " WHERE stk_nm LIKE ? OR stk_cd LIKE ?";
        $params[] = '%' . $search_term . '%';
        $params[] = '%' . $search_term . '%';
    }

    $sql .= " ORDER BY trde_amt DESC"; // 거래대금 기준으로 내림차순 정렬

    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);
    $data = $stmt->fetchAll();

} catch (PDOException $e) {
    $error_message = "데이터베이스 연결 또는 쿼리 오류: " . htmlspecialchars($e->getMessage());
    error_log("Database error in fetch_all_stocks.php: " . $e->getMessage());
} catch (Exception $e) {
    $error_message = "예상치 못한 오류가 발생했습니다: " . htmlspecialchars($e->getMessage());
    error_log("Unexpected error in fetch_all_stocks.php: " . $e->getMessage());
}

// 데이터 표시
if (!empty($error_message)) {
    echo "<p class=\"error\">" . $error_message . "</p>";
} elseif (!empty($data)) {
    if (!empty($search_term)) {
        echo "<p>'" . htmlspecialchars($search_term) . "' 검색 결과: 총 " . count($data) . "개의 종목을 찾았습니다.</p>";
    } else {
        echo "<p>데이터베이스에서 총 " . count($data) . "개의 종목을 불러왔습니다. (거래대금 순 정렬)</p>";
    }

    echo "<table>";
    echo "<thead><tr><th>종목코드</th><th>종목명</th><th>현재가</th><th>전일대비</th><th>등락률</th><th>거래량</th><th>거래대금</th></tr></thead>";
    echo "<tbody>";
    foreach ($data as $stock) {
        echo "<tr>";
        echo "<td>" . htmlspecialchars($stock['stk_cd'] ?? '') . "</td>";
        echo "<td>" . htmlspecialchars($stock['stk_nm'] ?? '') . "</td>";
        echo "<td>" . htmlspecialchars(number_format($stock['cur_prc'] ?? 0)) . "</td>";
        echo "<td>" . htmlspecialchars(number_format($stock['cmpr_yd'] ?? 0)) . "</td>";
        echo "<td>" . htmlspecialchars($stock['flu_rt'] ?? '') . "</td>";
        echo "<td>" . htmlspecialchars(number_format($stock['trde_qty'] ?? 0)) . "</td>";
        echo "<td>" . htmlspecialchars(number_format($stock['trde_amt'] ?? 0)) . "</td>";
        echo "</tr>";
    }
    echo "</tbody></table>";
} else {
    if (!empty($search_term)) {
        echo "<p>'" . htmlspecialchars($search_term) . "'에 대한 검색 결과가 없습니다.</p>";
    } else {
        echo "<p class=\"info\">데이터베이스에 조회된 종목이 없습니다. 파이썬 스크립트(get_all_stocks.py)를 먼저 실행하여 종목을 로드해주세요.</p>";
    }
}
?>
구현 및 실행 가이드
kiwoom_api.py 업데이트: 이전에 제공된 파일과 동일한 내용인지 확인하고, 필요한 경우 python_modules 폴더에 덮어쓰기 합니다.

get_all_stocks.py 업데이트: 이전에 제공된 파일과 동일한 내용인지 확인하고, 필요한 경우 python_modules 폴더에 덮어쓰기 합니다.

새 파일 생성 realtime_data_updater.py: python_modules 폴더 내에 realtime_data_updater.py 파일을 새로 생성하고, 위에 제공된 코드를 붙여넣습니다.

config.ini 확인: APP_KEY, APP_SECRET, BASE_URL이 올바르게 설정되어 있는지 다시 한번 확인합니다.

실행 순서 (중요!):

1단계: 종목 리스트 초기화 (최초 1회 및 주기적 실행)
get_all_stocks.py를 먼저 실행하여 stock_data.db에 종목 코드와 기본 정보를 채워 넣어야 합니다.

Bash

cd /home/stock/public_html/python_modules/
python3 get_all_stocks.py
이 스크립트는 콘솔에 아무것도 출력하지 않으며, 로그는 logs/kiwoom_api_YYYYMMDD.log에 기록됩니다.

2단계: 실시간 데이터 업데이트 (백그라운드에서 지속 실행)
이제 realtime_data_updater.py를 백그라운드에서 실행하여 stock_data.db의 '전일대비', '등락률', '거래량', '거래대금' 필드를 실시간으로 업데이트하게 합니다.

Bash

cd /home/stock/public_html/python_modules/
nohup python3 realtime_data_updater.py > /dev/null 2>&1 &
nohup ... & 명령은 터미널을 닫아도 스크립트가 백그라운드에서 계속 실행되도록 합니다. 로그는 logs/realtime_updater_YYYYMMDD.log에 기록됩니다.

fetch_all_stocks.php 업데이트: 이전에 제공된 파일과 동일한 내용인지 확인하고, 필요한 경우 public_html 폴더에 덮어쓰기 합니다.

웹페이지 확인: http://stock.mizrino.com/all_stocks.php 페이지를 새로고침하여 '전일대비', '등락률', '거래량', '거래대금' 컬럼에 실시간 데이터가 채워지는지 확인합니다.

참고:

realtime_data_updater.py의 update_stock_realtime_data 함수 내부에서 data.get('lastPrice', '0'), data.get('changeFromPrevDay', '0') 등으로 필드를 가져오는 부분은 실제 키움증권 모의투자 WebSocket API 응답의 JSON 구조에 따라 조정이 필요할 수 있습니다. logs/realtime_updater_YYYYMMDD.log 파일에 기록되는 실시간 시세 서버 응답 수신 로그를 확인하여 실제 응답 필드 이름을 확인 후 realtime_data_updater.py 파일을 수정해야 할 수도 있습니다.

모의투자 API의 WebSocket 구독 제한에 따라, 수천 개의 종목을 한 번에 구독하는 것이 불가능할 수 있습니다. 이 경우 subscribe_to_stocks 함수 내에서 종목 리스트를 여러 묶음으로 나누어 순차적으로 REG 요청을 보내는 로직(batching)을 구현해야 할 수 있습니다.